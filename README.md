# Практическое пособие по библиотеке requests языка программирования Python

## Оглавление
1. [Введение](#практическое-пособие-по-библиотеке-requests-языка-программирования-python)
2. [Оглавление](#оглавление)
3. [Что такое HTTP](#что-такое-протокол-http)
4. [Анатомия HTTP пакета](#анатомия-http-пакета)
5. [Что такое requests](#что-такое-requests)
6. [Методы HTTP запросов](#методы-http-запросов)
7. [Коды состояния HTTP](#коды-состояния-протокола-http)
7. [Заголовки HTTP запроса](#работа-с-заголовками-http-запроса)
8. [Использование cookie](#использование-сookie)
9. [Timeout HTTP запроса](#timeout-http-запроса)
10. [Использование HTTP proxy](#использование-http-proxy)
11. [Управление перенаправлениями (Redirect)](#управление-redirect)
12. [Передача файлов](#передача-файлов)
## Что такое протокол HTTP

**HTTP (Hyper Text Transfer Protocol)** – или протокол передачи гипертекста. Представляет собой протокол прикладного уровня модели **OSI**, предназначен для передачи данных в формате гипертекста между клиентом (браузером) и сервером, что хранит набор гипертекстовых документов

### История протокола HTTP
![Страница текстового браузера Line Mode c поддержкой HTTP/0.9](https://optional.is/required/wp-content/uploads/2013/09/lmb.jpg )  
_Страница браузера Line Mode_


Первая версия данного протокола была представлена [Джоном Бернерсом-Ли](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%BD%D0%B5%D1%80%D1%81-%D0%9B%D0%B8,_%D0%A2%D0%B8%D0%BC) и его командой в 1991 году. Протокол использовался для получения
гипертекстовых документов с удаленных серверов, и на момент выхода версии **HTTP/0.9** поддерживал лишь базовый функционал, такой как:
 
- Передача текстовых документов с дальнейшим отображением в окне терминала 

- Использование единичного TCP-соединения для передачи данных

- Поддержка единственного на тот момент **HTTP** метода — **GET**

Как можно догадаться, первая версия данного протокола хорошо справлялась с решением простых задач, однако для внедрения более продвинутых функций,
к примеру передачи изображений и аудиозаписей, нуждалась в серьезной доработке, в том числе изменении ряда фундаментальных аспектов практической
реализации протокола

#### HTTP/1.0
С выпуском версии 1.0 в 1996 году, протокол HTTP постепенно начал отходить от концепции простой передачи текстовой информации, а также претерпел значительные
изменения по сравнению с первой реализацией протокола, среди нововведений можно выделить:
  
  - Добавление в структуру пакета полей заголовка (**User-Agent**, **Content-Type**, **Content-Length**, **Date** и т.д)
  - Введение системы статус-кодов (**200**, **404**, **500**, ...)
  - Добавление методов **POST** и **HEAD**
  - Поддержка MIME-типов т.е **CSS**, **JS**, и мультимедиа (аудио, изображения, и т.д)

Однако несмотря на ряд обширных, и без сомнений прорывных для 1996 года изменений, **HTTP/1.0** сохранил ряд низкоуровневых проблем о некоторых из которых уже было упомянуто ранее, к примеру:
  - Cоздание нового TCP-соединения при каждом обращении к серверу
  - **Head-of-Line-Blocking (HOLB)** – или остановка передачи данных в случае ошибки передачи одного из сегментов

Из этого можно заключить, что версия 1.0 протокола **HTTP** была революционной для своего времени, а также ввела ряд фундаментальных концепций протокола **HTTP**, однако все также содержала проблемы связанные с использованием синхронной передачи данных через протокол TCP, и производительностью на стороне как клиента, так и сервера

#### HTTP/1.1

## Анатомия HTTP пакета
![Обмен HTTP-сообщениями между сервером и клиентом](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS5bIyO9eaoRmjxB2g7CJa8KIVCQRv0jbFglQ&s)

Перед тем как перейти к описанию структуры **HTTP** пакета, стоит разобраться в правилах, по которым в протоколе **HTTP** происходит обмен данными между хостами. **HTTP** — протокол построенный на базе клиент-серверной архитектуры, из чего закономерно следует, что передача данных в данном протоколе происходит посредством обмена двумя **HTTP** сообщениями:

 - **Request** — запрос от клиента к серверу
 
 - **Response** — ответ сервера на запрос клиента

Как было сказано в разделе [История протокола HTTP](#история-протокола-http), начиная с версии **HTTP/2** сообщения данного протокола передаются в формате бинарных сообщений, однако при декодировании т.е переводе в текстовый формат, обыкновенно выглядят следующим образом:

• Пример простейшего **GET** запроса
```http
GET /page HTTP/2
Host: site.com
User-Agent: python-requests/2.32
Accept: text/html
Accept-Language: en-US
Accept-Encoding: gzip, deflate
Connection: keep-alive
 ```

• Ответ на **GET** запрос
```http
HTTP/2 200 OK
Date: Mon, 16 Jun 2025 03:56:24 GMT
Server: nginx/1.29.0
Content-Type: text/html charset=UTF-8
Content-Length: 150
Connection: close

<html>
 <head>
  <title>Page title</title>
 </head>
 <body>
  Body
 </body>
</html>
```

Выше был приведен пример простейшего **GET** запроса, и ответа на него ввиде лаконичного **HTML** документа, однако содержание **HTTP** сообщений, наверняка вызвало ряд вопросов, поэтому стоит подробнее рассмотреть их структуру


### Структура **GET** запроса
- **Начальная строка HTTP запроса, содержит ключевую информацию пакета т.е страницу**
   - **GET** – обозначает метод **HTTP** запроса, распожен в начале пакета
   - **/page** – путь до страницы, которую запрашивает клиент
   - **HTTP/2** – версия протокола **HTTP** на стороне клиента
```http
GET /page HTTP/2
```
- **Заголовки HTTP запроса**
  - **Host** – заголовок для указания доменного имени или IP-адреса к которому обращается клиенту
  - **User-Agent** – заголовок для указания ПО (и, или) устройства с помощью которого был сделан запрос, помогает адаптировать ответ в зависимости от платформы пользователя
  - **Accept** – данный заголовок указывает допустимый формат для передачи данных в ответе на запрос
  - **Accept-Language** – заголовок, сообщающий серверу о языке, на котором клиент предпочитает получить ответ
  - **Accept-Encoding** – заголовок, необязательный к применению. Содержит данные о алгоритме сжатия, который поддерживает клиент. В нашем примере, сервер вернет ответ сжатый с помощью алгоритма [Deflate](https://ru.wikipedia.org/wiki/Deflate) 
  - **Connection** – заголовок для хранения информации о состоянии подключения, к примеру в нашем примере используется **keep-alive**
```http
Host: site.com
User-Agent: python-requests/2.32
Accept: text/html
Accept-Language: ru-RU
Accept-Encoding: gzip, deflate
Connection: keep-alive
```


### Структура ответа на **GET** запрос
- **Начальная строка HTTP ответа**
  - **HTTP/2** – версия протокола **HTTP** на стороне сервера
  - **200** – Статус-код **HTTP** ответа, при успешной передаче запрошенных данных равен **200**
```http
HTTP/2 200 OK
```
- **Заголовки HTTP ответа**
  - **Date** – заголовок хранящий дату и время отправки ответа на сторону клиента
  - **Server** – содержит информацию о сервере, который обрабатывал запрос клиента в нашем примере это **Nginx** версии **1.29.0**
  - **Content-Type** – заголовок используемый для хранения информации о формате данных в ответе, а также кодировке тела **HTTP** ответа
  - **Content-Length** – содержит данные о количестве байт в теле **HTTP** ответа 
  - **Connection** – как было обозначено выше, данный заголовок отображает текущее состояние подключения, в случае если данный заголовок имеет значение **close**, соединение считается закрытым 
```http
Date: Mon, 16 Jun 2025 03:56:24 GMT
Server: nginx/1.29.0
Content-Type: text/html charset=UTF-8
Content-Length: 75
Connection: close
```
- **Тело (Body) HTTP ответа в формате HTML (с одним отступом между заголовками и телом)**
```html
<html>
  <head>
   <title>Page title</title>
  </head>
  <body>
    Body 
  </body>
</html>
```
### Итоги
В данном разделе мы рассмотрели алгоритм, по которому происходит передача данных через протокол **HTTP**, а также cтруктуру **HTTP** пакетов с типами **Request** и **Response**. Также стоит помнишь, что выше был приведен лишь простейший пример, и в зависимости от потребностей, а также версии протокола **HTTP** пакет может содержать дополнительные заголовки, а правила форматирования пакета могут быть различны. Для полноценного ознакомления с данными правилами, стоит ознакомится с спецификацией [RFC-9113](https://datatracker.ietf.org/doc/html/rfc9113), а также спецификациями, которые относятся к другим версиям данного протокола

## Что такое requests

## Методы HTTP запросов
В рамках общей архитектуры протокола **HTTP**, не последнюю роль играет необходимость правильного разделения функций, которые используются для проведения операций с неким ресурсом. Данная проблема была решена еще в первой версии данного протокола (**HTTP/0.9**), посредством введения концепции **HTTP методов**

**HTTP метод** - представляет собой короткую последовательность символов в верхнем регистре, например (**GET**, **POST**, **PUT**, ...), которые выполняют роль указания функции запроса. К примеру метод **GET** служит для получения данных с удаленного сервера, а метод **POST** для их отправки. Ниже представлены подробные описания базовых **HTTP** методов, а также примеры их использования с помощью библиотеки **requsts**

### Метод GET
Как было сказано ранее, метод **GET** используется для запроса и получения данных со стороны удаленного сервера, и используется обычными пользователями ежедневно при открытии сайтов через веб-браузер, или использовании других приложений, которые запрашивают данные через протокол **HTTP**. В данном блоке мы рассмотрим простейший пример использования данного метода, а также попробуем воспользоваться его расширенным функционалом, т.е передачей данных внутри **URL**

**Отправка GET запроса с использованием библиотеки requests**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get") # Делаем GET запрос по указанному URL
print(res.url) # Отображаем URL на который был сделан запрос
print(res.text) # Отображаем ответ на запрос в текстовом виде
print(res.json()) # Отображаем ответ в формате декодированного JSON
```

**Отправка GET запроса с данными в URL**
```python
import requests # Импортируем библиотеку requests

payload = {"key": "value"} # Данные для отправки в GET запросе

res = requests.get("https://httpbin.org/get", params=payload) # Делаем GET запрос к httpbin.org
print(f"Host: {res.url}") # Отображаем URL с переданными данными
print(f"Raw: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

### Метод POST
Данный метод является одним из базовых на равне с **GET**, используется для отправки данных на удаленные **HTTP** сервера. Используется обычными пользователями на ежедневной основе, например при создании учетных записей на различных сервисах, или отправке сообщений при использовании мессенджером. Ниже будет рассмотрен пример использования метода POST для отправки данных ввиде формы, а также в формате **JSON**

**Отправка формы через POST запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Ivan", "age": 40} # Данные формы для отправки в теле POST запроса

res = requests.post("https://httpbin.org/post", data=payload) # Делаем POST запрос на https:/httpbin.org/post
print(f"Raw: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

**Отправка POST запроса c JSON в теле запроса**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Ivan", "age": 40} # Данные формы для отправки в теле POST запроса

res = requests.post("https://httpbin.org/post", json=payload) # Делаем POST запрос на https:/httpbin.org/post
print(f"Result: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

### Метод PUT
Метод **PUT** обыкновенно используется в рамках полной замены некого ресурса на удаленном сервере. В качестве примера повседневного использования можно привести операции по изменению имени пользователя, или редактирования поста на форуме. Стоит отметить, что в отличии от метода PATCH, что будет рассмотрен ниже, метод PUT подразумевает обновление ресурса посредством отправки его копии с внесенными изменениями, а не отдельных атрибутов. Базовые операции с методом **PUT**, будут рассмотрены ниже 

**Отправка данных формы через PUT запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Name", "age": 40} # Данные формы

res = requests.put("https://httpbin.org/put", data=payload) Делаем запрос к URL https://httpbin.org/put
print(res.text) # Отображаем тело ответа в текстовом формате
```

**Отправка данных в формате JSON через PUT запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Name", "age": 40} # Данные формы

res = requests.put("https://httpbin.org/put", json=payload) Делаем PUT запрос к URL https://httpbin.org/put
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```
### Метод DELETE
Как можно понять из навания, метод **DELETE** служит для удаления с **HTTP** сервера некого ресурса. Данный метод поддерживает как отправку запроса без содержимого в теле, так и с внедрением полезной нагрузки. Оба вида использования метода **DELETE** будут рассмотрены на практических примерах ниже

**Отправка простого DELETE запроса**
```python
import requests # Импортируем библиотеку requests

res = requests.delete("https://httpbin.org/delete") # Делаем DELETE запрос к https://httpbin.org/delete
print(res.text) # Отображаем тело ответа в текстовом формате
```
**Отправка DELETE запроса c данными в URL**

```python
import requests # Импортируем библиотеку requests

params = {"id": 456} # Данные для отправки
res = requests.delete("https://httpbin.org/delete", params=params) # Делаем DELETE запрос к https://httpbin.org/delete c с данными в URL

print(res.url) # Отображаем URL DELETE запроса
print(res.text) # Отображаем тело ответа в текстовом формате
```
### Метод PATCH
Данный метод служит для обновления указанного в **URL** ресурса на удаленном сервере, однако в отличии от метода **PUT**, который также служит для обновления данных, метод **PATCH** выполняет идентичную функцию, при этом заменяя не весь ресурс, а лишь отдельные его атрибуты 
**Отправка PATCH запроса с полезной нагрузкой**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Victor"} # Данные для отправки в теле PATCH запроса
res = requests.patch("https://httpbin.org/patch", data=payload) # Делаем запрос к https://httpbin.org/patch с полезной нагрузкой внутри тела запроса

print(res.text) # Отображаем тело ответа в текстовом формате
```

**Отправка PATCH запроса с полезной нагрузкой в формате JSON**
```python
import requests # Импортируем библиотеку requests

payload = {"age": 35} # Данные для отправки в теле PATCH запроса

res = requests.patch("https://httpbin.org/patch", json=payload) # Делаем запрос к https://httpbin.org/patch с полезной нагрузкой в формате JSON.
print(res.text) # Отображаем тело ответа в текстовом формате
```

### Метод HEAD
Метод **HEAD** является одним из методов, использование которого не подразумевает отправку тела запроса или его получение, предоставляя пользователю лишь заголовки **HTTP** ответа. В подавляющем большинстве случаев используется для получения служебной информации из заголовка перед скачиванием больших объемов данных, однако может использоваться для решения других задач, например для проверки доступности ресурса по определенному **URL**. Пример простейшего **HEAD** запроса представлен ниже

**Отправка HEAD запроса для получение заголовка ответа**
```python
import requests # Импортируем библиотеку requests

res = requests.head("https://httpbin.org/")
print(f"Headers: {res.headers}")
```
### Метод OPTIONS
Функционал данного метода практически идентичен функционалу метода **HEAD**, однако в отличии от последнего, также возвращает ряд служебной информации, к примеру список разрешенных ресурсом методов для взаимодействия. В примере ниже, мы запросим список доступных методов у ресурса httpbin.org через заголовок **Allow**, а также выведем все заголовки рассматриваемого ответа

**Отправка OPTIONS запроса для получения списка доступных методов**
```python
import requests # Импортируем библиотеку requests

res = requests.options("https://httpbin.org/")
print(f"Allow methods: {res.headers['Allow'}")
```
## Коды состояния протокола HTTP
## Обработка ошибок HTTP запроса

Как можно понять из содержания предыдущего раздела, при выполнении **HTTP** запроса клиент может столкнуться с рядом непредвиденных ошибок, как со стороны сервера, так и со стороны клиента. Для корректного функционирования приложений использующих библиотеку **requests** в качестве **HTTP** клиента, необходимо обеспечить отслеживание и обработку ошибок, которые могут возникнуть во время работы программного обеспечения. Для решения данной проблемы в рамках бибилотеки **requests**, был разработан модуль **exceptions**, который является частью ядра библиотеки

Данный модуль содержит перечень классов для обработки наиболее частых ошибок, например неожиданный разрыв соединения, или отсутствие запрашиваемого ресурса на удаленном сервере. Ниже перечислен ряд часто используемых исключений, а также описание типа ошибок, которые они обрабатывают:

### **RequestException**
Является родительским классом всех исключений в рамках библиотеки requests. Обрабатывает любые ошибки, которые могут возникнуть в рамках HTTP запроса, и уместен к использованию, если нет необходимости в отдельной обработке типов исключений

Пример обработки исключения **RequestException**
```python
import requests
from requests.exceptions import RequestException

try:
    res = requests.get("https://httpbin.org/djsjwk23i3fkd8", timeout=0.0000001)

except RequestException as e: print(f"Произошла ошибка: {e}")

```
### **ConnectionError**
Данное исключение вызывается при наличии проблем с подключением к удаленному серверу. Наиболее распрастраненными причинами вызова данного исключения можно считать разрыв **TCP** соединения, отсутствие подключения к сети, или остановку работы запрашиваемого сервера

Пример обработки исключения **ConnectionError**
```python
import requests
from requests.exceptions import ConnectionError

try:
    res = requests.get("https://httpbin.org/get")

except ConnectionError as e: print(f"Ошибка подключения к серверу: {e}")

```
### **HTTPError**
Данное исключение вызывается в случае если ответ сервера содержит коды состояния **4xx**, **5xxx** т.е на стороне клиента(**4xx**) или на стороне сервера (**5xx**) присутствует ошибка

Пример обработки исключения **HTTPError**
```python
import requests
from requests.exceptions import HTTPError

try:
    res = requests.get("https://httpbin.org/fnej3sneksmk")
    res.raise_for_status()

except HTTPError as e: print(f"Ошибка HTTP запроса: {e}")

```

### **Timeout**
Вызывается в том случае, если удаленный сервер не вернул ответ (**Response**) на запрос клиента в установленный клиентом временной интервал

Пример обработки исключения **Timeout**
```python
import requests
from requests.exceptions import Timeout

try:
    res = requests.get("https://httpbin.org/get", timeout=0.00003)

except Timeout as e: print(f"Превышен установленный интервал ожидания ответа: {e}")

```

## Работа с заголовками HTTP запроса
Заголовки являются важной, и обязательной частью **HTTP** пакета. Как было обозначено ранее, заголовки **HTTP** пакета содржат в себе служебную информацию о пакете, которая необходима при обработке запроса, а также формировании ответа.

Несмотря на то, что в подавляющем большинстве случаев библиотека **requests** автоматически устанавливает значения необходимых заголовков, иногда возникает необходимость в добавлении новых заголовков, и/или модификации уже существующих. 

К счастью, библиотека **requests** предоставляет такую возможность, через установку значений заголовков внутри словаря, и дальнейшую установку в качестве значения атрибута **headers**. Пример управления заголовками **POST** запроса представлен ниже

**Модификация заголовков POST запроса**
```python
import requests # Импортируем библиотеку requests

data = {"name": "Ivan", "age": 40} # Данные для отправки в теле POST запроса

headers = {
"Content-Type": "application/json",
"User-Agent": "custom-useragent/1.0"
} # Новые значения заголовков HTTP запроса

res = requests.post("https://httpbin.org/post", headers=headers, json=data) # Делаем POST запрос к указанному URL с обновленными заголовками 

print(f"Content-Type: {res.request.headers['Content-Type']}") # Отображаем значение заголовка Content-Type
print(f"User-Agent: {res.request.headers['User-Agent']}") # Отображаем значение заголовка User-Agent
```

## Использование Сookie
При использовании сервисов требующих аутентификации, пользователи уже давно привыкли к отсутствии необходимости повторного входа в свою учетную запись при обновлении страницы, или каждый раз заново выставлять настройки кастомизации страницы, однако не каждый задумывался о том, как был реализован данный механизм. Ранее описанный функционал корректно работает благодаря заголовку под названием **Cookie**

### Что такое Cookie
**Cookie** — это заголовок **HTTP** запроса, хранящий в себе некий набор данных, для дальнейшего использования на стороне сервера. При отправке запроса к ресурсу через браузер, последний берет на себя функции по сохранению и управлению **cookie**, однако пользователь имеет возможность удаления и модификации этих данных. 

Также стоит отметить, что файлы **cookie** из-за наличия в них конфиденциальной информации, являются одной из главных целей вредоносного ПО для сбора данных, поэтому в подавляющем баольшинстве случаев, содержимое файлов **cookie** хранится и передается в зашифрованном виде. 

Однако в примере представленном ниже, **cookie** передаются в обычном формате, так как не несут в себе никакой ценности, и служат лишь для демонстрации работы с данным заголовком

**Пример использования cookie в GET запросе**
```python
import requests # Импортируем библиотеку requests

cookies = {"session_id": 15372828878} # Данные для передачи в cookie GET запроса

res = requests.get("https://httpbin.org/cookie", cookies=cookies) # Делаем GET запрос с добавлением cookie
print(f"Cookie: {res.json['cookies']}") # Отображаем содержимое заголовка cookie
```

## Timeout HTTP запроса
По ряду технических причин, временной интервал получения ответа от удаленного сервера на **HTTP** запрос может превышать стандартный интервал для операций схожего типа, и как следствие снижать производительность **HTTP** клиента

К сожалению предотвратить причины задержек не всегда представляется возможным, однако клиент имеет возможность избежать потерь времени, прервав **TCP** соединение с удаленным сервером по истечении указанного интервала.

В библиотеке **requests** данный метод экономии временных ресурсов реализован с помощью атрибута **timeout**. Данный атрибут принимает в качестве значения целое число (**int**) или число с плавающей точкой (**float**) обозначающее длину интервала в рамках которого должен быть получен ответ от сервера. Пример выполнения **GET** запроса с ограниченным интервалом ожидания ответа представлен ниже

**Отправка HTTP запроса с ограниченным интервалом ожидания ответа**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get", timeout=2) # Делаем GET запрос с ограниченным интервалом ожидания ответа
print(res.text) # Отображаем тело HTTP ответа
```
## Использование HTTP proxy
При разработке определенных видов программного обеспечения, к примеру так называемых [парсеров](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D1%81%D0%BA%D1%80%D0%B5%D0%B9%D0%BF%D0%B8%D0%BD%D0%B3), может возникнуть необходимость отправки запросов не напрямую к целевому ресурсу, а через посредника, который примет запрос от клиента и передаст его серверу, после вернув ответ сервера клиенту.

В рамках протокола **HTTP** данная проблема решается с помощью [**HTTP прокси**](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). **HTTP прокси** одновременно выполняет роль как сервера, так и клиента, сначала принимая запрос в качестве сервера, а после передающая его целевому ресурсу в качестве клиента. Подробнее ознакомиться с концепцией прокси серверов можно перейдя по ссылкам оставленным выше.

Библиотека **requests** также предоставляет возможность для отправки запросов через прокси сервера, принимая данные последних через атрибут **proxies** в формате словаря. Пример отправки **HTTP** запроса через прокси сервер, приведен ниже

**Отправка HTTP запроса через proxy сервер**
```python
import requests # Импортируем библиотеку requests

proxies = {
"http": "10.10.10.10:80",
"https": "10.10.10.10:443"
}

res = requests.get("https://ifconfig.me/ip", proxies=proxies)
print(res.text)
```
## Управление redirect
Концепция **redirect** уже была рассмотрена в разделе о [кодах состояния HTTP](#коды-состояния-протокола-http), поэтому в текущем разделе будут описаны практические методы управления данным механизмом с помощью библиотеки **requests**. Примеры управления перернаправлениями приведены ниже


**Отключение автоматического перенаправления на предложенный URL**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get", allow_redirects=False) # Делаем GET запрос с отключением автоматического перенаправление на предложенный URL
print(res.status_code) # Отображаем код состояния (301, 302)
```


**Установка ограничения на количество перенаправлений**
```python
import requests # Импортируем библиотеку requests
from requests.exceptions import TooManyRedirects # Импортируем исключение TooManyRedirects
try:
  res = requests.get("https://httpbin.org/get", max_redirects=10) # Делаем GET запрос с органичением по количеству перенаправлений 
  print(res.status_code) # Отображаем код состояния (301, 302)

except TooManyRedirects: print("Превышено количество перенаправлений")
```


**Отображение истории перенаправлений**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get", allow_redirect=False) # Делаем GET запрос для получения истории перенаправлений

# Отображаем историю перенаправлений из заголовка HTTP ответа
print("История перенаправлений:") 
for url in res.history: print(url)

```

## Передача файлов

Одной из распространенных задач при работе с библиотекой **requests** можно назвать проведение операций над файлами различных форматов. 
Существует основных два типа операций с файлами в рамках протокола **HTTP**:
 
 - **Upload** — отправка файла на удаленный сервер, ввиде последовательности байт
      
 - **Download** — или отправка запроса к удаленному серверу на получение массива байт, и его дальнейшей записи в пустой файл

В случае если файл имеет небольшой размер, допустима передача его содержимого одним фрагментом, однако в большинстве случаев корректней
осуществлять передачу файла по частям, которые принято называть [чанками](https://ru.wikipedia.org/wiki/Chunked_transfer_encoding). 

Ниже приведены примеры скачивания (**Download**) и загрузки (**Upload**) содержимого файлов по фрагментам, с помощью базовых методов библиотеки **requests**

**Скачивание файла с удаленного сервера (Download)**
```python
import requests # Импортируем библиотеку requests
from requests.exceptions import RequestException # Импортируем исключение RequestException

try:
    res = requests.get("https://httpbin.org/image/png", stream=True) # Делаем GET запрос для получения файла с удаленного сервера ввиде последовательности байт
    res.raise_for_status()

    if res.status_code == 200: 
        with open("image.png", "wb") as file: # Открываем файл image.png на запись байтов без кодировки
            for chunk in res.iter_content(chunk_size=2048): file.write(chunk) # Записываем изображение в файл image.png по 2048 байт за итерацию
            print("Скачивание завершено") # Отображаем уведомление об успешном завершении операции 

except requests.exceptions.RequestError as e: print(f"Произошла ошибка при скачивании файла: {e}")
```

**Загрузка файла на удаленный сервер (Upload)**
```python
import requests # Импортируем библиотеку requests
from requests.exceptions import RequestException # Импортируем исключение

file = {"file": open("filename.ext", "rb")} # Содержимое файла ввиде последовательности байт внутри словаря

try:
  res = requests.post("https://httpbin.org/post", files=file) # Делаем POST запрос к https://httpbin.org/post загружая на сервер файл ввиде последовательности байт
  print(f"[{res.status_code}] Файл был загружен по адресу {res.url}") # Отображаем уведомление об успешной загрузке файла на сервер 

except RequestException as e: print(f"Произошла ошибка при загрузке файла: {e}")
```
