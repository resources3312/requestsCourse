# Практическое пособие по библиотеке requests языка программирования Python

## Оглавление
1. [Введение](#практическое-пособие-по-библиотеке-requests-языка-программирования-python)
2. [Оглавление](#оглавление)
3. [Что такое HTTP](#что-такое-протокол-http)
4. [Анатомия HTTP пакета](#анатомия-http-пакета)
5. [Что такое requests](#что-такое-requests)
6. [Методы HTTP запросов]()
## Что такое протокол HTTP

**HTTP (Hyper Text Transfer Protocol)** – или протокол передачи гипертекста. Представляет собой протокол прикладного уровня модели **OSI**, предназначен для передачи данных в формате гипертекста между клиентом (браузером) и сервером, что хранит набор гипертекстовых документов

### История протокола HTTP
![Страница текстового браузера Line Mode c поддержкой HTTP/0.9](https://optional.is/required/wp-content/uploads/2013/09/lmb.jpg )  
_Страница браузера Line Mode_


Первая версия данного протокола была представлена [Джоном Бернерсом-Ли](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%BD%D0%B5%D1%80%D1%81-%D0%9B%D0%B8,_%D0%A2%D0%B8%D0%BC) и его командой в 1991 году. Протокол использовался для получения
гипертекстовых документов с удаленных серверов, и на момент выхода версии **HTTP/0.9** поддерживал лишь базовый функционал, такой как:
 
- Передача текстовых документов с дальнейшим отображением в окне терминала 

- Использование единичного TCP-соединения для передачи данных

- Поддержка единственного на тот момент **HTTP** метода — **GET**

Как можно догадаться, первая версия данного протокола хорошо справлялась с решением простых задач, однако для внедрения более продвинутых функций,
к примеру передачи изображений и аудиозаписей, нуждалась в серьезной доработке, в том числе изменении ряда фундаментальных аспектов практической
реализации протокола

#### HTTP/1.0
С выпуском версии 1.0 в 1996 году, протокол HTTP постепенно начал отходить от концепции простой передачи текстовой информации, а также претерпел значительные
изменения по сравнению с первой реализацией протокола, среди нововведений можно выделить:
  
  - Добавление в структуру пакета полей заголовка (**User-Agent**, **Content-Type**, **Content-Length**, **Date** и т.д)
  - Введение системы статус-кодов (**200**, **404**, **500**, ...)
  - Добавление методов **POST** и **HEAD**
  - Поддержка MIME-типов т.е **CSS**, **JS**, и мультимедиа (аудио, изображения, и т.д)

Однако несмотря на ряд обширных, и без сомнений прорывных для 1996 года изменений, **HTTP/1.0** сохранил ряд низкоуровневых проблем о некоторых из которых уже было упомянуто ранее, к примеру:
  - Cоздание нового TCP-соединения при каждом обращении к серверу
  - **Head-of-Line-Blocking (HOLB)** – или остановка передачи данных в случае ошибки передачи одного из сегментов

Из этого можно заключить, что версия 1.0 протокола **HTTP** была революционной для своего времени, а также ввела ряд фундаментальных концепций протокола **HTTP**, однако все также содержала проблемы связанные с использованием синхронной передачи данных через протокол TCP, и производительностью на стороне как клиента, так и сервера

#### HTTP/1.1

## Анатомия HTTP пакета
![Обмен HTTP-сообщениями между сервером и клиентом](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS5bIyO9eaoRmjxB2g7CJa8KIVCQRv0jbFglQ&s)

Перед тем как перейти к описанию структуры **HTTP** пакета, стоит разобраться в правилах, по которым в протоколе **HTTP** происходит обмен данными между хостами. **HTTP** — протокол построенный на базе клиент-серверной архитектуры, из чего закономерно следует, что передача данных в данном протоколе происходит посредством обмена двумя **HTTP** сообщениями:

 - **Request** — запрос от клиента к серверу
 
 - **Response** — ответ сервера на запрос клиента

Как было сказано в разделе [История протокола HTTP](#история-протокола-http), начиная с версии **HTTP/2** сообщения данного протокола передаются в формате бинарных сообщений, однако при декодировании т.е переводе в текстовый формат, обыкновенно выглядят следующим образом:

• Пример простейшего **GET** запроса
```http
GET /page HTTP/2
Host: site.com
User-Agent: python-requests/2.32
Accept: text/html
Accept-Language: en-US
Accept-Encoding: gzip, deflate
Connection: keep-alive
 ```

• Ответ на **GET** запрос
```http
HTTP/2 200 OK
Date: Mon, 16 Jun 2025 03:56:24 GMT
Server: nginx/1.29.0
Content-Type: text/html charset=UTF-8
Content-Length: 150
Connection: close

<html>
 <head>
  <title>Page title</title>
 </head>
 <body>
  Body
 </body>
</html>
```

Выше был приведен пример простейшего **GET** запроса, и ответа на него ввиде лаконичного **HTML** документа, однако содержание **HTTP** сообщений, наверняка вызвало ряд вопросов, поэтому стоит подробнее рассмотреть их структуру


### Структура **GET** запроса
- **Начальная строка HTTP запроса, содержит ключевую информацию пакета т.е страницу**
   - **GET** – обозначает метод **HTTP** запроса, распожен в начале пакета
   - **/page** – путь до страницы, которую запрашивает клиент
   - **HTTP/2** – версия протокола **HTTP** на стороне клиента
```http
GET /page HTTP/2
```
- **Заголовки HTTP запроса**
  - **Host** – заголовок для указания доменного имени или IP-адреса к которому обращается клиенту
  - **User-Agent** – заголовок для указания ПО (и, или) устройства с помощью которого был сделан запрос, помогает адаптировать ответ в зависимости от платформы пользователя
  - **Accept** – данный заголовок указывает допустимый формат для передачи данных в ответе на запрос
  - **Accept-Language** – заголовок, сообщающий серверу о языке, на котором клиент предпочитает получить ответ
  - **Accept-Encoding** – заголовок, необязательный к применению. Содержит данные о алгоритме сжатия, который поддерживает клиент. В нашем примере, сервер вернет ответ сжатый с помощью алгоритма [Deflate](https://ru.wikipedia.org/wiki/Deflate) 
  - **Connection** – заголовок для хранения информации о состоянии подключения, к примеру в нашем примере используется **keep-alive**
```http
Host: site.com
User-Agent: python-requests/2.32
Accept: text/html
Accept-Language: ru-RU
Accept-Encoding: gzip, deflate
Connection: keep-alive
```


### Структура ответа на **GET** запрос
- **Начальная строка HTTP ответа**
  - **HTTP/2** – версия протокола **HTTP** на стороне сервера
  - **200** – Статус-код **HTTP** ответа, при успешной передаче запрошенных данных равен **200**
```http
HTTP/2 200 OK
```
- **Заголовки HTTP ответа**
  - **Date** – заголовок хранящий дату и время отправки ответа на сторону клиента
  - **Server** – содержит информацию о сервере, который обрабатывал запрос клиента в нашем примере это **Nginx** версии **1.29.0**
  - **Content-Type** – заголовок используемый для хранения информации о формате данных в ответе, а также кодировке тела **HTTP** ответа
  - **Content-Length** – содержит данные о количестве байт в теле **HTTP** ответа 
  - **Connection** – как было обозначено выше, данный заголовок отображает текущее состояние подключения, в случае если данный заголовок имеет значение **close**, соединение считается закрытым 
```http
Date: Mon, 16 Jun 2025 03:56:24 GMT
Server: nginx/1.29.0
Content-Type: text/html charset=UTF-8
Content-Length: 75
Connection: close
```
- **Тело (Body) HTTP ответа в формате HTML (с одним отступом между заголовками и телом)**
```html
<html>
  <head>
   <title>Page title</title>
  </head>
  <body>
    Body 
  </body>
</html>
```
### Итоги
В данном разделе мы рассмотрели алгоритм, по которому происходит передача данных через протокол **HTTP**, а также cтруктуру **HTTP** пакетов с типами **Request** и **Response**. Также стоит помнишь, что выше был приведен лишь простейший пример, и в зависимости от потребностей, а также версии протокола **HTTP** пакет может содержать дополнительные заголовки, а правила форматирования пакета могут быть различны. Для полноценного ознакомления с данными правилами, стоит ознакомится с спецификацией [RFC-9113](https://datatracker.ietf.org/doc/html/rfc9113), а также спецификациями, которые относятся к другим версиям данного протокола

## Что такое requests

## Методы HTTP запросов
В рамках общей архитектуры протокола **HTTP**, не последнюю роль играет необходимость правильного разделения функций, которые используются для проведения операций с неким ресурсом. Данная проблема была решена еще в первой версии данного протокола (**HTTP/0.9**), посредством введения концепции **HTTP методов**

**HTTP метод** - представляет собой короткую последовательность символов в верхнем регистре, например (**GET**, **POST**, **PUT**, ...), которые выполняют роль указания функции запроса. К примеру метод **GET** служит для получения данных с удаленного сервера, а метод **POST** для их отправки. Ниже представлены подробные описания базовых **HTTP** методов, а также примеры их использования с помощью библиотеки **requsts**

### Метод GET
Как было сказано ранее, метод **GET** используется для запроса и получения данных со стороны удаленного сервера, и используется обычными пользователями ежедневно при открытии сайтов через веб-браузер, или использовании других приложений, которые запрашивают данные через протокол **HTTP**. В данном блоке мы рассмотрим простейший пример использования данного метода, а также попробуем воспользоваться его расширенным функционалом, т.е передачей данных внутри **URL**

**Отправка GET запроса с использованием библиотеки requests**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get") # Делаем GET запрос по указанному URL
print(res.url) # Отображаем URL на который был сделан запрос
print(res.text) # Отображаем ответ на запрос в текстовом виде
print(res.json()) # Отображаем ответ в формате декодированного JSON
```

**Отправка GET запроса с данными в URL**
```python
import requests # Импортируем библиотеку requests

payload = {"key": "value"} # Данные для отправки в GET запросе

res = requests.get("https://httpbin.org/get", params=payload) # Делаем GET запрос к httpbin.org
print(f"Host: {res.url}") # Отображаем URL с переданными данными
print(f"Raw: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

### Метод POST
Данный метод является одним из базовых на равне с **GET**, используется для отправки данных на удаленные **HTTP** сервера. Используется обычными пользователями на ежедневной основе, например при создании учетных записей на различных сервисах, или отправке сообщений при использовании мессенджером. Ниже будет рассмотрен пример использования метода POST для отправки данных ввиде формы, а также в формате **JSON**

**Отправка формы через POST запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Ivan", "age": 40} # Данные формы для отправки в теле POST запроса

res = requests.post("https://httpbin.org/post", data=payload) # Делаем POST запрос на https:/httpbin.org/post
print(f"Raw: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

**Отправка POST запроса c JSON в теле запроса**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Ivan", "age": 40} # Данные формы для отправки в теле POST запроса

res = requests.post("https://httpbin.org/post", json=payload) # Делаем POST запрос на https:/httpbin.org/post
print(f"Result: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

### Метод PUT
Метод **PUT** обыкновенно используется в рамках полной замены некого ресурса на удаленном сервере. В качестве примера повседневного использования можно привести операции по изменению имени пользователя, или редактирования поста на форуме. Стоит отметить, что в отличии от метода PATCH, что будет рассмотрен ниже, метод PUT подразумевает обновление ресурса посредством отправки его копии с внесенными изменениями, а не отдельных атрибутов. Базовые операции с методом **PUT**, будут рассмотрены ниже 

**Отправка данных формы через PUT запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Name", "age": 40} # Данные формы

res = requests.put("https://httpbin.org/put", data=payload) Делаем запрос к URL https://httpbin.org/put
print(res.text) # Отображаем тело ответа в текстовом формате
```

**Отправка данных в формате JSON через PUT запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Name", "age": 40} # Данные формы

res = requests.put("https://httpbin.org/put", json=payload) Делаем PUT запрос к URL https://httpbin.org/put
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```
### Метод DELETE
Как можно понять из навания, метод **DELETE** служит для удаления с **HTTP** сервера некого ресурса. Данный метод поддерживает как отправку запроса без содержимого в теле, так и с внедрением полезной нагрузки. Оба вида использования метода **DELETE** будут рассмотрены на практических примерах ниже

**Отправка простого DELETE запроса**
```python
import requests # Импортируем библиотеку requests

res = requests.delete("https://httpbin.org/delete") # Делаем DELETE запрос к https://httpbin.org/delete
print(res.text) # Отображаем тело ответа в текстовом формате
```
**Отправка DELETE запроса c данными в URL**

```python
import requests # Импортируем библиотеку requests

params = {"id": 456} # Данные для отправки
res = requests.delete("https://httpbin.org/delete", params=params) # Делаем DELETE запрос к https://httpbin.org/delete c с данными в URL

print(res.url) # Отображаем URL DELETE запроса
print(res.text) # Отображаем тело ответа в текстовом формате
```
### Метод PATCH
Данный метод служит для обновления указанного в **URL** ресурса на удаленном сервере, однако в отличии от метода **PUT**, который также служит для обновления данных, метод **PATCH** выполняет идентичную функцию, при этом заменяя не весь ресурс, а лишь отдельные его атрибуты 
**Отправка PATCH запроса с полезной нагрузкой**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Victor"} # Данные для отправки в теле PATCH запроса
res = requests.patch("https://httpbin.org/patch", data=payload) # Делаем запрос к https://httpbin.org/patch с полезной нагрузкой внутри тела запроса

print(res.text) # Отображаем тело ответа в текстовом формате
```

**Отправка PATCH запроса с полезной нагрузкой в формате JSON**
```python
import requests # Импортируем библиотеку requests

payload = {"age": 35} # Данные для отправки в теле PATCH запроса

res = requests.patch("https://httpbin.org/patch", json=payload) # Делаем запрос к https://httpbin.org/patch с полезной нагрузкой в формате JSON.
print(res.text) # Отображаем тело ответа в текстовом формате
```

### Метод HEAD
Метод **HEAD** является одним из методов, использование которого не подразумевает отправку тела запроса или его получение, предоставляя пользователю лишь заголовки **HTTP** ответа. В подавляющем большинстве случаев используется для получения служебной информации из заголовка перед скачиванием больших объемов данных, однако может использоваться для решения других задач, например для проверки доступности ресурса по определенному **URL**. Пример простейшего **HEAD** запроса представлен ниже

**Отправка HEAD запроса для получение заголовка ответа**
```python
import requests # Импортируем библиотеку requests

res = requests.head("https://httpbin.org/")
print(f"Headers: {res.headers}")
```
### Метод OPTIONS
Функционал данного метода практически идентичен функционалу метода **HEAD**, однако в отличии от последнего, также возвращает ряд служебной информации, к примеру список разрешенных ресурсом методов для взаимодействия. В примере ниже, мы запросим список доступных методов у ресурса httpbin.org через заголовок **Allow**, а также выведем все заголовки рассматриваемого ответа

**Отправка OPTIONS запроса для получения списка доступных методов**
```python
import requests # Импортируем библиотеку requests

res = requests.options("https://httpbin.org/")
print(f"Allow methods: {res.headers['Allow'}")
```
## Коды состояния протокола HTTP
## Обработка ошибок HTTP запроса

Как можно понять из содержания предыдущего раздела, при выполнении **HTTP** запроса клиент может столкнуться с рядом непредвиденных ошибок, как со стороны сервера, так и со стороны клиента. Для корректного функционирования приложений использующих библиотеку **requests** в качестве **HTTP** клиента, необходимо обеспечить отслеживание и обработку ошибок, которые могут возникнуть во время работы программного обеспечения. Для решения данной проблемы в рамках бибилотеки **requests**, был разработан модуль **exceptions**, который является частью ядра библиотеки

Данный модуль содержит перечень классов для обработки наиболее частых ошибок, например неожиданный разрыв соединения, или отсутствие запрашиваемого ресурса на удаленном сервере. Ниже перечислен ряд часто используемых исключений, а также описание типа ошибок, которые они обрабатывают:

### **RequestException**
Является родительским классом всех исключений в рамках библиотеки requests. Обрабатывает любые ошибки, которые могут возникнуть в рамках HTTP запроса, и уместен к использованию, если нет необходимости в отдельной обработке типов исключений

Пример обработки исключения **RequestException**
```python
import requests
from requests.exceptions import RequestException

try:
    res = requests.get("https://httpbin.org/djsjwk23i3fkd8", timeout=0.0000001)

except RequestException as e: print(f"Произошла ошибка: {e}")

```
### **ConnectionError**
Данное исключение вызывается при наличии проблем с подключением к удаленному серверу. Наиболее распрастраненными причинами вызова данного исключения можно считать разрыв **TCP** соединения, отсутствие подключения к сети, или остановку работы запрашиваемого сервера

Пример обработки исключения **ConnectionError**
```python
import requests
from requests.exceptions import ConnectionError

try:
    res = requests.get("https://httpbin.org/get")

except ConnectionError as e: print(f"Ошибка подключения к серверу: {e}")

```
### **HTTPError**
Данное исключение вызывается в случае если ответ сервера содержит коды состояния **4xx**, **5xxx** т.е на стороне клиента(**4xx**) или на стороне сервера (**5xx**) присутствует ошибка

Пример обработки исключения **HTTPError**
```python
import requests
from requests.exceptions import HTTPError

try:
    res = requests.get("https://httpbin.org/fnej3sneksmk")
    res.raise_for_status()

except HTTPError as e: print(f"Ошибка HTTP запроса: {e}")

```

### **Timeout**
Вызывается в том случае, если удаленный сервер не вернул ответ (**Response**) на запрос клиента в установленный клиентом временной интервал

Пример обработки исключения **Timeout**
```python
import requests
from requests.exceptions import Timeout

try:
    res = requests.get("https://httpbin.org/get", timeout=0.00003)

except Timeout as e: print(f"Превышен установленный интервал ожидания ответа: {e}")

```
