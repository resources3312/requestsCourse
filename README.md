# Практическое руководство по библиотеке requests языка программирования Python
Данное руководство представляет собой структурированный перечень разделов описывающий основные аспекты работы с библиотекой requests языка программирования Python. 

Разделы данного руководства преимущественно ориентированы на демонстрацию практических примеров использования библиотеки requests, однако разделы описывающие теоретические концепции протокола HTTP также присутствуют 

Для понимания представленного материала обучающемуся необязательно иметь глубокие знания о работе языка программирования Python или функционировании компьютерных сетей, однако наличие базовых навыков программирования на языке Python являются абсолютной необходимостью для освоения представленных концепций

Также стоит отметить, что данное руководство не ставит цели рассказать о всех аспектах рассматриваемой темы, а лишь дает базовые навыки для самостоятельного погружения в тему, и представляет примеры небольших проектов, для реализации которых необходимо владеть рассматриваемым инструментом

## Оглавление
1. [Введение](#практическое-пособие-по-библиотеке-requests-языка-программирования-python)
2. [Оглавление](#оглавление)
3. [Что такое HTTP](#что-такое-протокол-http)
4. [Анатомия HTTP пакета](#анатомия-http-пакета)
5. [Библиотека requests](#библиотека-requests)
6. [Методы HTTP запросов](#методы-http-запросов)
7. [Коды состояния HTTP](#коды-состояния-протокола-http)
7. [Заголовки HTTP запроса](#работа-с-заголовками-http-запроса)
8. [Использование cookie](#использование-сookie)
9. [Timeout HTTP запроса](#timeout-http-запроса)
10. [Использование HTTP proxy](#использование-http-proxy)
11. [Управление перенаправлениями (Redirect)](#управление-redirect)
12. [Передача файлов](#передача-файлов)
13. [Аутентификация](#аутентификация)
14. [HTTP cессии (Session)](#http-сессии)
## Что такое протокол HTTP

**HTTP (Hyper Text Transfer Protocol)** – или протокол передачи гипертекста. Представляет собой протокол прикладного уровня модели **OSI**, предназначен для передачи данных в формате гипертекста между клиентом (браузером) и сервером, что хранит набор гипертекстовых документов

### История протокола HTTP
![Страница текстового браузера Line Mode c поддержкой HTTP/0.9](https://optional.is/required/wp-content/uploads/2013/09/lmb.jpg )  
_Страница браузера Line Mode_


Первая версия данного протокола была представлена [Джоном Бернерсом-Ли](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%BD%D0%B5%D1%80%D1%81-%D0%9B%D0%B8,_%D0%A2%D0%B8%D0%BC) и его командой в 1991 году. Протокол использовался для получения
гипертекстовых документов с удаленных серверов, и на момент выхода версии **HTTP/0.9** поддерживал лишь базовый функционал, такой как:
 
- Передача текстовых документов с дальнейшим отображением в окне терминала 

- Использование единичного TCP-соединения для передачи данных

- Поддержка единственного на тот момент **HTTP** метода — **GET**

Как можно догадаться, первая версия данного протокола хорошо справлялась с решением простых задач, однако для внедрения более продвинутых функций,
к примеру передачи изображений и аудиозаписей, нуждалась в серьезной доработке, в том числе изменении ряда фундаментальных аспектов практической
реализации протокола

#### HTTP/1.0
С выпуском версии 1.0 в 1996 году, протокол HTTP постепенно начал отходить от концепции простой передачи текстовой информации, а также претерпел значительные
изменения по сравнению с первой реализацией протокола, среди нововведений можно выделить:
  
  - Добавление в структуру пакета полей заголовка (**User-Agent**, **Content-Type**, **Content-Length**, **Date** и т.д)
  - Введение системы статус-кодов (**200**, **404**, **500**, ...)
  - Добавление методов **POST** и **HEAD**
  - Поддержка MIME-типов т.е **CSS**, **JS**, и мультимедиа (аудио, изображения, и т.д)

Однако несмотря на ряд обширных, и без сомнений прорывных для 1996 года изменений, **HTTP/1.0** сохранил ряд низкоуровневых проблем о некоторых из которых уже было упомянуто ранее, к примеру:
  - Cоздание нового TCP-соединения при каждом обращении к серверу
  - **Head-of-Line-Blocking (HOLB)** – или остановка передачи данных в случае ошибки передачи одного из сегментов

Из этого можно заключить, что версия 1.0 протокола **HTTP** была революционной для своего времени, а также ввела ряд фундаментальных концепций протокола **HTTP**, но все также содержала проблемы связанные с использованием синхронной передачи данных через протокол TCP, и производительностью на стороне как клиента, так и сервера

#### HTTP/1.1

По прошествии трех лет с момента выпуска HTTP/1.0, Джоном Бернерсом-Ли и его командой была представлена новая версия протокола — HTTP/1.1
На следующие 16 лет (до выпуска HTTP/2) данная версия протокола HTTP стала стандартом в сфере разработки веб приложений, и имеет широкое применение среди современных веб приложений на сегодняшний день, несмотря на то, что с момента выпуска HTTP/1.1 прошло 26 лет

Столь широкое распространение данной версии можно обьяснить внедрением ряда механизмов, использование которых увеличило производительность, и дало возможность разработчикам использовать протокол HTTP для быстрой передачи больших объемов данных. Ниже приведен перечень основных нововведений данной версии, и их краткие описания

- **Механизм keep-alive** — использование которого позволяет проводить передачу данных в рамках одного TCP соединения, не тратя аппаратные ресурсы на открытие новых TCP соединений

- **Сжатие (Accept-Encoding)** — метод уменьшения размера тела HTTP пакетов, благодаря их сжатию с помощью предложенного клиентом алгоритма шифрования

- **Кеширование (Cache-Control, ...)** — механизм позволяющий увеличить скорость загрузки страниц и снять нагрузку с сервера благодаря хранению части информации на стороне клиента

- **Фрагментированная отправка тела HTTP пакета (Range, Content-Range)** — данная техника передачи тела HTTP пакета делает возможным быструю передачу больших объемом данных в рамках одного HTTP запроса

- **Добавление новых методов запросов (PUT, DELETE, OPTIONS, TRACE)** — значительно расширило возможности применения протокола HTTP для  решения задач выходящих за пределы функционала базовых запросов 


#### HTTP/2
Несмотря на ранее перечисленные достоинства HTTP/1.1, с ростом всемирной паутины и как следствие требований к скорости загрузки контента, версия протокола HTTP выпущенная в конце 90-х годов перестала удовлетворять ожиданиям пользователей и разработчиков, поэтому в мае 2015 года, была выпущена новая версия — HTTP/2

С выпуском версии HTTP/2, структура протокола HTTP притерпела ряд существенных изменений, которые впрочем, затрагивали лишь технические аспекты протокола, оставляя концептуальные части структуры прежними. 

Список упомянутых выше изменений структуры протокола рассмотрены ниже:

- **Переход на бинарный формат передачи пакетов** — отказ от текстового формата отразился на читаемости HTTP пакетов, однако вместе с тем значительно увеличил скорость обработки пакетов, и как следствие снижению аппаратных затрат на стороне как клиента, так и сервера

- **Сжатие заголовков (HPACK)** — механизм использующий алгоритм HPACK для сжатия строк заголовков, и как следствие снижение аппаратных расходов на их передачу

- **Мультиплексирование** — метод оптимизации передачи данных внутри TCP соединения, за счет их передачи через потоки, что позволяет производить одновременную отправку нескольких запросов к серверу, существенно снижая временные затраты на передачу данных

- **Автоматическая передача статических данных (Server Push)** — данный механизм призван сократить количество запросов к серверу для получения статических данных (CSS, JS) с помощью их отправки в рамках передачи HTML документа


#### HTTP/3

**HTTP/3 (QUIC)** — был представлен в июне 2022 года, и на сегодняшний день является последней версией протокола HTTP. 

Вернувшись к описаниям изменений предыдущих реализаций, можно явно проследить, что большая часть нововведений связана с прикладными концепциями, такими как добавление новых методов запросов, алгоримтов сжатия тела запроса, и т.д. 

Однако изменения в HTTP/3 затрагивают более фундаментальные части структуры рассматриваемого протокола, быть точнее, начиная с  данной версии разработчики отказались от использования транспортного протокола TCP, в пользу экспериментального транспортного протокола **QUIC (Quick UDP Internet Connections)** разработанного компанией Google.

Смена транспортного протокола была обусловлена рядом проблем связанных с производительностью протокола HTTP, решение которых без выхода за рамки протокола TCP не представляется возможным.
В свою очередь использование транспортного протокола QUIC основанного на UDP, решает подавляющее большинство проблем связанных использованием TCP соединений, благодаря передачи данных с помощью так называемых **датаграмм (Datagram)**, тем самым кратно увеличивая скорость передачи пакетов, при этом жертвуя гарантией целостности данных, которую предоставляет использовавшийся ранее протокол TCP. Однако стоит заметить что описанный ранее естественный недостаток протокола QUIC, компенсируется наличием несовершенных, но предотвращающих большую часть потерь механизмов. 

Исходя из вышесказанного можно заключить, что переход протокола HTTP на QUIC является радикальным, но необходимым шагом для дальнейшего развития данного протокола

## Анатомия HTTP пакета

Перед тем как перейти к описанию структуры **HTTP** пакета, стоит разобраться в правилах, по которым в протоколе **HTTP** происходит обмен данными между хостами. **HTTP** — протокол построенный на базе клиент-серверной архитектуры, из чего закономерно следует, что передача данных в данном протоколе происходит посредством обмена двумя **HTTP** сообщениями:

 - **Request** — запрос от клиента к серверу
 
 - **Response** — ответ сервера на запрос клиента

Как было сказано в разделе [История протокола HTTP](#история-протокола-http), начиная с версии **HTTP/2** сообщения данного протокола передаются в формате бинарных сообщений, однако при декодировании т.е переводе в текстовый формат, обыкновенно выглядят следующим образом:

• Пример простейшего **GET** запроса
```http
GET /page HTTP/2
Host: site.com
User-Agent: python-requests/2.32
Accept: text/html
Accept-Language: en-US
Accept-Encoding: gzip, deflate
Connection: keep-alive
 ```

• Ответ на **GET** запрос
```http
HTTP/2 200 OK
Date: Mon, 16 Jun 2025 03:56:24 GMT
Server: nginx/1.29.0
Content-Type: text/html charset=UTF-8
Content-Length: 150
Connection: close

<html>
 <head>
  <title>Page title</title>
 </head>
 <body>
  Body
 </body>
</html>
```

Выше был приведен пример простейшего **GET** запроса, и ответа на него ввиде лаконичного **HTML** документа, однако содержание **HTTP** сообщений, наверняка вызвало ряд вопросов, поэтому стоит подробнее рассмотреть их структуру


### Структура **GET** запроса
- **Начальная строка HTTP запроса, содержит ключевую информацию пакета т.е страницу**
   - **GET** – обозначает метод **HTTP** запроса, распожен в начале пакета
   - **/page** – путь до страницы, которую запрашивает клиент
   - **HTTP/2** – версия протокола **HTTP** на стороне клиента
```http
GET /page HTTP/2
```
- **Заголовки HTTP запроса**
  - **Host** – заголовок для указания доменного имени или IP-адреса к которому обращается клиенту
  - **User-Agent** – заголовок для указания ПО (и, или) устройства с помощью которого был сделан запрос, помогает адаптировать ответ в зависимости от платформы пользователя
  - **Accept** – данный заголовок указывает допустимый формат для передачи данных в ответе на запрос
  - **Accept-Language** – заголовок, сообщающий серверу о языке, на котором клиент предпочитает получить ответ
  - **Accept-Encoding** – заголовок, необязательный к применению. Содержит данные о алгоритме сжатия, который поддерживает клиент. В нашем примере, сервер вернет ответ сжатый с помощью алгоритма [Deflate](https://ru.wikipedia.org/wiki/Deflate) 
  - **Connection** – заголовок для хранения информации о состоянии подключения, к примеру в нашем примере используется **keep-alive**
```http
Host: site.com
User-Agent: python-requests/2.32
Accept: text/html
Accept-Language: ru-RU
Accept-Encoding: gzip, deflate
Connection: keep-alive
```


### Структура ответа на **GET** запрос
- **Начальная строка HTTP ответа**
  - **HTTP/2** – версия протокола **HTTP** на стороне сервера
  - **200** – Статус-код **HTTP** ответа, при успешной передаче запрошенных данных равен **200**
```http
HTTP/2 200 OK
```
- **Заголовки HTTP ответа**
  - **Date** – заголовок хранящий дату и время отправки ответа на сторону клиента
  - **Server** – содержит информацию о сервере, который обрабатывал запрос клиента в нашем примере это **Nginx** версии **1.29.0**
  - **Content-Type** – заголовок используемый для хранения информации о формате данных в ответе, а также кодировке тела **HTTP** ответа
  - **Content-Length** – содержит данные о количестве байт в теле **HTTP** ответа 
  - **Connection** – как было обозначено выше, данный заголовок отображает текущее состояние подключения, в случае если данный заголовок имеет значение **close**, соединение считается закрытым 
```http
Date: Mon, 16 Jun 2025 03:56:24 GMT
Server: nginx/1.29.0
Content-Type: text/html charset=UTF-8
Content-Length: 75
Connection: close
```
- **Тело (Body) HTTP ответа в формате HTML (с одним отступом между заголовками и телом)**
```html
<html>
  <head>
   <title>Page title</title>
  </head>
  <body>
    Body 
  </body>
</html>
```
### Итоги
В данном разделе мы рассмотрели алгоритм, по которому происходит передача данных через протокол **HTTP**, а также cтруктуру **HTTP** пакетов с типами **Request** и **Response**. Также стоит помнишь, что выше был приведен лишь простейший пример, и в зависимости от потребностей, а также версии протокола **HTTP** пакет может содержать дополнительные заголовки, а правила форматирования пакета могут быть различны. Для полноценного ознакомления с данными правилами, стоит ознакомится с спецификацией [RFC-9113](https://datatracker.ietf.org/doc/html/rfc9113), а также спецификациями, которые относятся к другим версиям данного протокола

## Библиотека requests

![Логотип библиотеки requests](https://datascientest.com/wp-content/uploads/2022/04/requests-1.jpg)
_Логотип библиотеки requests_

**Requests** — библиотека языка программирования Python, созданная для быстрого, и интуитивно понятного взаимодействия с протоколом HTTP в качестве клиента. Данная библиотека построена на базе **urllib3**, во многом представляя собой совокупность интерфейсов к ранее упомянутой библиотеке, тем самым освобождая разработчиков от необходимости ручной реализации многих механизмов протокола HTTP, и в полной мере отражая главный принцип библиотеки — **HTTP for humans**

Установка данной библиотеки является тривиальной задачей благодаря отсутствию внешних зависимостей, и решается с помощью вызова одной команды

**Установка requests через pip**
```shell
pip install requests
```

## Методы HTTP запросов
В рамках общей архитектуры протокола **HTTP**, не последнюю роль играет необходимость правильного разделения функций, которые используются для проведения операций с неким ресурсом. Данная проблема была решена еще в первой версии данного протокола (**HTTP/0.9**), посредством введения концепции **HTTP методов**

**HTTP метод** - представляет собой короткую последовательность символов в верхнем регистре, например (**GET**, **POST**, **PUT**, ...), которые выполняют роль указания функции запроса. К примеру метод **GET** служит для получения данных с удаленного сервера, а метод **POST** для их отправки. Ниже представлены подробные описания базовых **HTTP** методов, а также примеры их использования с помощью библиотеки **requsts**

### Метод GET
Как было сказано ранее, метод **GET** используется для запроса и получения данных со стороны удаленного сервера, и используется обычными пользователями ежедневно при открытии сайтов через веб-браузер, или использовании других приложений, которые запрашивают данные через протокол **HTTP**. В данном блоке мы рассмотрим простейший пример использования данного метода, а также попробуем воспользоваться его расширенным функционалом, т.е передачей данных внутри **URL**

**Отправка GET запроса с использованием библиотеки requests**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get") # Делаем GET запрос по указанному URL
print(res.url) # Отображаем URL на который был сделан запрос
print(res.text) # Отображаем ответ на запрос в текстовом виде
print(res.json()) # Отображаем ответ в формате декодированного JSON
```

**Отправка GET запроса с данными в URL**
```python
import requests # Импортируем библиотеку requests

payload = {"key": "value"} # Данные для отправки в GET запросе

res = requests.get("https://httpbin.org/get", params=payload) # Делаем GET запрос к httpbin.org
print(f"Host: {res.url}") # Отображаем URL с переданными данными
print(f"Raw: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

### Метод POST
Данный метод является одним из базовых на равне с **GET**, используется для отправки данных на удаленные **HTTP** сервера. Используется обычными пользователями на ежедневной основе, например при создании учетных записей на различных сервисах, или отправке сообщений при использовании мессенджером. Ниже будет рассмотрен пример использования метода POST для отправки данных ввиде формы, а также в формате **JSON**

**Отправка формы через POST запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Ivan", "age": 40} # Данные формы для отправки в теле POST запроса

res = requests.post("https://httpbin.org/post", data=payload) # Делаем POST запрос на https:/httpbin.org/post
print(f"Raw: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

**Отправка POST запроса c JSON в теле запроса**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Ivan", "age": 40} # Данные формы для отправки в теле POST запроса

res = requests.post("https://httpbin.org/post", json=payload) # Делаем POST запрос на https:/httpbin.org/post
print(f"Result: {res.text}") # Отображаем тело ответа в текстовом формате
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```

### Метод PUT
Метод **PUT** обыкновенно используется в рамках полной замены некого ресурса на удаленном сервере. В качестве примера повседневного использования можно привести операции по изменению имени пользователя, или редактирования поста на форуме. Стоит отметить, что в отличии от метода PATCH, что будет рассмотрен ниже, метод PUT подразумевает обновление ресурса посредством отправки его копии с внесенными изменениями, а не отдельных атрибутов. Базовые операции с методом **PUT**, будут рассмотрены ниже 

**Отправка данных формы через PUT запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Name", "age": 40} # Данные формы

res = requests.put("https://httpbin.org/put", data=payload) Делаем запрос к URL https://httpbin.org/put
print(res.text) # Отображаем тело ответа в текстовом формате
```

**Отправка данных в формате JSON через PUT запрос**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Name", "age": 40} # Данные формы

res = requests.put("https://httpbin.org/put", json=payload) Делаем PUT запрос к URL https://httpbin.org/put
print(f"Json: {res.json()}") # Отображаем тело ответа в формате словаря
```
### Метод DELETE
Как можно понять из навания, метод **DELETE** служит для удаления с **HTTP** сервера некого ресурса. Данный метод поддерживает как отправку запроса без содержимого в теле, так и с внедрением полезной нагрузки. Оба вида использования метода **DELETE** будут рассмотрены на практических примерах ниже

**Отправка простого DELETE запроса**
```python
import requests # Импортируем библиотеку requests

res = requests.delete("https://httpbin.org/delete") # Делаем DELETE запрос к https://httpbin.org/delete
print(res.text) # Отображаем тело ответа в текстовом формате
```
**Отправка DELETE запроса c данными в URL**

```python
import requests # Импортируем библиотеку requests

params = {"id": 456} # Данные для отправки
res = requests.delete("https://httpbin.org/delete", params=params) # Делаем DELETE запрос к https://httpbin.org/delete c с данными в URL

print(res.url) # Отображаем URL DELETE запроса
print(res.text) # Отображаем тело ответа в текстовом формате
```
### Метод PATCH
Данный метод служит для обновления указанного в **URL** ресурса на удаленном сервере, однако в отличии от метода **PUT**, который также служит для обновления данных, метод **PATCH** выполняет идентичную функцию, при этом заменяя не весь ресурс, а лишь отдельные его атрибуты 
**Отправка PATCH запроса с полезной нагрузкой**
```python
import requests # Импортируем библиотеку requests

payload = {"name": "Victor"} # Данные для отправки в теле PATCH запроса
res = requests.patch("https://httpbin.org/patch", data=payload) # Делаем запрос к https://httpbin.org/patch с полезной нагрузкой внутри тела запроса

print(res.text) # Отображаем тело ответа в текстовом формате
```

**Отправка PATCH запроса с полезной нагрузкой в формате JSON**
```python
import requests # Импортируем библиотеку requests

payload = {"age": 35} # Данные для отправки в теле PATCH запроса

res = requests.patch("https://httpbin.org/patch", json=payload) # Делаем запрос к https://httpbin.org/patch с полезной нагрузкой в формате JSON.
print(res.text) # Отображаем тело ответа в текстовом формате
```

### Метод HEAD
Метод **HEAD** является одним из методов, использование которого не подразумевает отправку тела запроса или его получение, предоставляя пользователю лишь заголовки **HTTP** ответа. В подавляющем большинстве случаев используется для получения служебной информации из заголовка перед скачиванием больших объемов данных, однако может использоваться для решения других задач, например для проверки доступности ресурса по определенному **URL**. Пример простейшего **HEAD** запроса представлен ниже

**Отправка HEAD запроса для получение заголовка ответа**
```python
import requests # Импортируем библиотеку requests

res = requests.head("https://httpbin.org/")
print(f"Headers: {res.headers}")
```
### Метод OPTIONS
Функционал данного метода практически идентичен функционалу метода **HEAD**, однако в отличии от последнего, также возвращает ряд служебной информации, к примеру список разрешенных ресурсом методов для взаимодействия. В примере ниже, мы запросим список доступных методов у ресурса httpbin.org через заголовок **Allow**, а также выведем все заголовки рассматриваемого ответа

**Отправка OPTIONS запроса для получения списка доступных методов**
```python
import requests # Импортируем библиотеку requests

res = requests.options("https://httpbin.org/")
print(f"Allow methods: {res.headers['Allow'}")
```

## Коды состояния протокола HTTP
**Коды состояния** — являются одной из важнейших концепций протокола HTTP. Представляют собой трехзначный код расположенный в начальной строке ответа на HTTP запрос, и хранят в себе информацию о состоянии отправленного запроса, т.е результат с которым была завершена операция. Классификация кодов состояния насчитывает 5 основных групп на которые делятся данные коды, их более детальный разбор приведен ниже


**Информационные коды (1xx)**
Данная группа кодов состояния служит для пeредачи клиенту информационных сообщений о событиях в рамках обработки текущего запроса, явно индицирует что запрос был принят сервером и находится в стадии обработки. Ниже приведены примеры наиболее распрастраненных информационных кодов состояния

- **[100] Continue** – код состояния который сообщает клиенту о том, что его запрос принят сервером, и он может продолжать передачу тела запроса
- **[101] Switching Protocols** – код состояния сообщающий клиенту, что сервер согласен переключиться на протокол указанный в заголовке запроса **Upgrade**
- **[101] Processing** – данный код состояния означает что сервер принял запрос клиента, и находится в процессе его обработки

**Пример GET запроса возвращающий код состояния [100]** 
```python
import requests

res = requests.get("https://httpbin.org/status/100")
print(res.status_code)
```
### Коды успешного завершения операции (2xx)
Группа кодов состояния оповещающая клиента об успешном завершении обработки его запроса сервером. Наиболее распрастраненным кодом состояния из данной группы можно считать код **200**, однако помимо ранее упомянутого кода, данная группа также содержит такие коды как:

- **[201] Created** – сообщает о том, что операция по созданию нового ресурса завершена успешно
- **[202] Accepted** – возвращется сервером в том случае, если им были успешно отправлены заголовки ответа, однако передача тела может занять некоторое время
- **[204] No Content** – может быть получен клиентом, если сервер отправил лишь заголовки ответа, однако не смог произвести передачу тела по ряду причин

**Пример GET запроса возвращающий код состояния [200]**
```python
import requests

res = requests.get("https://httpbin.org/")
print(res.status_code)
```

### Коды паренаправления (3xx)
Данная группа кодов состояния несет в себе не только функцию передачи информации, а также реализует механизм протокола **HTTP** называемый **Redirect**.

**Redirect** – представляет собой одну из механик протокола **HTTP**, служит для перенаправления клиента с исходного **URL**, на тот **URL** что был предложен сервером. Данная техника рекомендуется к использованию при решении таких задач как перенаправление пользователей ресурса со старого домена на новый, или уведомление пользователя о смене маршрута, на котором находится интересующая его страница ресурса

Ниже приведены основные коды состояния из группы перенаправления (**3xx**) с их кратким описанием

- **[301] Moved Permanently** – служит для уведомления клиента о том, что запрашиваемый им ресурс был окончательно перенесен на новый **URL**
- **[302] Moved Temporarily** – уведомляет клиента что запрашиваемый им ресурс был временно перенесен на другой адрес, однако вскоре будет доступен по прежнему адресу
- **[304] Not Modified** – возвращается сервером только в том случае, если клиент отправил запрос для проверки отсутствия модификаций в гипертекстовом документе с момента последнего запроса

**Пример GET запроса возвращающий код состояния [300]**
```python
import requests

res = requests.get("https://httpbin.org/status/300")
print(res.status_code)
```

### Коды ошибок клиента (4xx)
Группа кодов состояния которая задействуется сервером в том случае, если причиной возникновения ошибки запроса является клиент, и проблемы на стороне сервера отсутствуют. 
Ниже представлены наиболее распространенные коды состояния из описываемой группы, а также краткое описание их назначения

- **[400] Bad Request** – данный код состояния служит для оповещения клиента о том, что в его запросе содержится синтаксическая ошибка. С подобным результатом часто сталкиваются программисты, которые работают с протоколом **HTTP** на уровне **API** протоколов транспортного уровня, однако данный код ошибки может получить и обычный пользователь. Ниже приведен перечень основных кодов состояния из данной группы
  
- **[401] Unauthorized** – возвращается клиенту с том случае, если он пытается сделать запрос к ресурсу, для получени которого требуется аутентификация. Также возвращается в случае, еси клиент представил аутентификационные данные, однако сервер не расценил их как корректные
- **[403] Forbidden** – применяется в том случае, если клиент сделал запрос к ресурсу с ограниченными правами доступа
- **[404] Not Found** – данный код состояния является наиболее узнаваемым среди обычных пользователей, прежде всего из-за частоты проявления связанной с ним ошибки, быть точнее отсутствия на сервере запрашиваемого пользователем ресурса

**Пример GET запроса который возвращает код состояния [404]**
```python
import requests

res = requests.get("https://httpbin.org/foawoejfwoiefj23f0")
print(res.status_code)
```
### Коды ошибок сервера (5xx)
Данная группа кодов служит для уведомления клиента об ошибке, причиной которой являются проблемы на стороне сервера. Чаще могут получить ответ ввиде кода состояния из описанной группы. 

Наиболее распространенные коды состояния данной группы рассмотрены ниже

- **[500] Internal Server Error** – данный код состояния возвращается сервером в том случае, если внутренняя ошибка не соотвествует другим кодам состояния из группы ошибок сервера
- **[502] Bad Gateway** – возвращается клиенту в том случае, если сервер работающий в режиме прокси сервера, не смог получить корректный ответ от сервера, к которому был сделан запрос
- **[505] HTTP Version Not Supported** – несет в себе функцию уведомления клиента о том, что сервер не поддерживает работу с версией протокола **HTTP** используемой клиентом
 
**Пример GET запроса, что возвращает код состояния [500]**
```python
import requests

res = requests.get("https://httpbin.org/status/500")
print(res.status_code)
```
## Обработка ошибок HTTP запроса

Как можно понять из содержания предыдущего раздела, при выполнении **HTTP** запроса клиент может столкнуться с рядом непредвиденных ошибок, как со стороны сервера, так и со стороны клиента. Для корректного функционирования приложений использующих библиотеку **requests** в качестве **HTTP** клиента, необходимо обеспечить отслеживание и обработку ошибок, которые могут возникнуть во время работы программного обеспечения. Для решения данной проблемы в рамках бибилотеки **requests**, был разработан модуль **exceptions**, который является частью ядра библиотеки

Данный модуль содержит перечень классов для обработки наиболее частых ошибок, например неожиданный разрыв соединения, или отсутствие запрашиваемого ресурса на удаленном сервере. Ниже перечислен ряд часто используемых исключений, а также описание типа ошибок, которые они обрабатывают:

### **RequestException**
Является родительским классом всех исключений в рамках библиотеки requests. Обрабатывает любые ошибки, которые могут возникнуть в рамках HTTP запроса, и уместен к использованию, если нет необходимости в отдельной обработке типов исключений

Пример обработки исключения **RequestException**
```python
import requests
from requests.exceptions import RequestException

try:
    res = requests.get("https://httpbin.org/djsjwk23i3fkd8", timeout=0.0000001)

except RequestException as e: print(f"Произошла ошибка: {e}")

```
### **ConnectionError**
Данное исключение вызывается при наличии проблем с подключением к удаленному серверу. Наиболее распрастраненными причинами вызова данного исключения можно считать разрыв **TCP** соединения, отсутствие подключения к сети, или остановку работы запрашиваемого сервера

Пример обработки исключения **ConnectionError**
```python
import requests
from requests.exceptions import ConnectionError

try:
    res = requests.get("https://httpbin.org/get")

except ConnectionError as e: print(f"Ошибка подключения к серверу: {e}")

```
### **HTTPError**
Данное исключение вызывается в случае если ответ сервера содержит коды состояния **4xx**, **5xxx** т.е на стороне клиента(**4xx**) или на стороне сервера (**5xx**) присутствует ошибка

Пример обработки исключения **HTTPError**
```python
import requests
from requests.exceptions import HTTPError

try:
    res = requests.get("https://httpbin.org/fnej3sneksmk")
    res.raise_for_status()

except HTTPError as e: print(f"Ошибка HTTP запроса: {e}")

```

### **Timeout**
Вызывается в том случае, если удаленный сервер не вернул ответ (**Response**) на запрос клиента в установленный клиентом временной интервал

Пример обработки исключения **Timeout**
```python
import requests
from requests.exceptions import Timeout

try:
    res = requests.get("https://httpbin.org/get", timeout=0.00003)

except Timeout as e: print(f"Превышен установленный интервал ожидания ответа: {e}")

```

## Работа с заголовками HTTP запроса
Заголовки являются важной, и обязательной частью **HTTP** пакета. Как было обозначено ранее, заголовки **HTTP** пакета содржат в себе служебную информацию о пакете, которая необходима при обработке запроса, а также формировании ответа.

Несмотря на то, что в подавляющем большинстве случаев библиотека **requests** автоматически устанавливает значения необходимых заголовков, иногда возникает необходимость в добавлении новых заголовков, и/или модификации уже существующих. 

К счастью, библиотека **requests** предоставляет такую возможность, через установку значений заголовков внутри словаря, и дальнейшую установку в качестве значения атрибута **headers**. Пример управления заголовками **POST** запроса представлен ниже

**Модификация заголовков POST запроса**
```python
import requests # Импортируем библиотеку requests

data = {"name": "Ivan", "age": 40} # Данные для отправки в теле POST запроса

headers = {
"Content-Type": "application/json",
"User-Agent": "custom-useragent/1.0"
} # Новые значения заголовков HTTP запроса

res = requests.post("https://httpbin.org/post", headers=headers, json=data) # Делаем POST запрос к указанному URL с обновленными заголовками 

print(f"Content-Type: {res.request.headers['Content-Type']}") # Отображаем значение заголовка Content-Type
print(f"User-Agent: {res.request.headers['User-Agent']}") # Отображаем значение заголовка User-Agent
```

## Использование Сookie
При использовании сервисов требующих аутентификации, пользователи уже давно привыкли к отсутствии необходимости повторного входа в свою учетную запись при обновлении страницы, или каждый раз заново выставлять настройки кастомизации страницы, однако не каждый задумывался о том, как был реализован данный механизм. Ранее описанный функционал корректно работает благодаря заголовку под названием **Cookie**

### Что такое Cookie
**Cookie** — это заголовок **HTTP** запроса, хранящий в себе некий набор данных, для дальнейшего использования на стороне сервера. При отправке запроса к ресурсу через браузер, последний берет на себя функции по сохранению и управлению **cookie**, однако пользователь имеет возможность удаления и модификации этих данных. 

Также стоит отметить, что файлы **cookie** из-за наличия в них конфиденциальной информации, являются одной из главных целей вредоносного ПО для сбора данных, поэтому в подавляющем баольшинстве случаев, содержимое файлов **cookie** хранится и передается в зашифрованном виде. 

Однако в примере представленном ниже, **cookie** передаются в обычном формате, так как не несут в себе никакой ценности, и служат лишь для демонстрации работы с данным заголовком

**Пример использования cookie в GET запросе**
```python
import requests # Импортируем библиотеку requests

cookies = {"session_id": 15372828878} # Данные для передачи в cookie GET запроса

res = requests.get("https://httpbin.org/cookie", cookies=cookies) # Делаем GET запрос с добавлением cookie
print(f"Cookie: {res.json['cookies']}") # Отображаем содержимое заголовка cookie
```

## Timeout HTTP запроса
По ряду технических причин, временной интервал получения ответа от удаленного сервера на **HTTP** запрос может превышать стандартный интервал для операций схожего типа, и как следствие снижать производительность **HTTP** клиента

К сожалению предотвратить причины задержек не всегда представляется возможным, однако клиент имеет возможность избежать потерь времени, прервав **TCP** соединение с удаленным сервером по истечении указанного интервала.

В библиотеке **requests** данный метод экономии временных ресурсов реализован с помощью атрибута **timeout**. Данный атрибут принимает в качестве значения целое число (**int**) или число с плавающей точкой (**float**) обозначающее длину интервала в рамках которого должен быть получен ответ от сервера. Пример выполнения **GET** запроса с ограниченным интервалом ожидания ответа представлен ниже

**Отправка HTTP запроса с ограниченным интервалом ожидания ответа**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get", timeout=2) # Делаем GET запрос с ограниченным интервалом ожидания ответа
print(res.text) # Отображаем тело HTTP ответа
```
## Использование HTTP proxy
При разработке определенных видов программного обеспечения, к примеру так называемых [парсеров](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D1%81%D0%BA%D1%80%D0%B5%D0%B9%D0%BF%D0%B8%D0%BD%D0%B3), может возникнуть необходимость отправки запросов не напрямую к целевому ресурсу, а через посредника, который примет запрос от клиента и передаст его серверу, после вернув ответ сервера клиенту.

В рамках протокола **HTTP** данная проблема решается с помощью [**HTTP прокси**](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). **HTTP прокси** одновременно выполняет роль как сервера, так и клиента, сначала принимая запрос в качестве сервера, а после передающая его целевому ресурсу в качестве клиента. Подробнее ознакомиться с концепцией прокси серверов можно перейдя по ссылкам оставленным выше.

Библиотека **requests** также предоставляет возможность для отправки запросов через прокси сервера, принимая данные последних через атрибут **proxies** в формате словаря. Пример отправки **HTTP** запроса через прокси сервер, приведен ниже

**Отправка HTTP запроса через proxy сервер**
```python
import requests # Импортируем библиотеку requests

proxies = {
"http": "10.10.10.10:80",
"https": "10.10.10.10:443"
}

res = requests.get("https://ifconfig.me/ip", proxies=proxies)
print(res.text)
```
## Управление redirect
Концепция **redirect** уже была рассмотрена в разделе о [кодах состояния HTTP](#коды-состояния-протокола-http), поэтому в текущем разделе будут описаны практические методы управления данным механизмом с помощью библиотеки **requests**. Примеры управления перернаправлениями приведены ниже


**Отключение автоматического перенаправления на предложенный URL**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get", allow_redirects=False) # Делаем GET запрос с отключением автоматического перенаправление на предложенный URL
print(res.status_code) # Отображаем код состояния (301, 302)
```


**Установка ограничения на количество перенаправлений**
```python
import requests # Импортируем библиотеку requests
from requests.exceptions import TooManyRedirects # Импортируем исключение TooManyRedirects
try:
  res = requests.get("https://httpbin.org/get", max_redirects=10) # Делаем GET запрос с органичением по количеству перенаправлений 
  print(res.status_code) # Отображаем код состояния (301, 302)

except TooManyRedirects: print("Превышено количество перенаправлений")
```


**Отображение истории перенаправлений**
```python
import requests # Импортируем библиотеку requests

res = requests.get("https://httpbin.org/get", allow_redirect=False) # Делаем GET запрос для получения истории перенаправлений

# Отображаем историю перенаправлений из заголовка HTTP ответа
print("История перенаправлений:") 
for url in res.history: print(url)

```

## Передача файлов

Одной из распространенных задач при работе с библиотекой **requests** можно назвать проведение операций над файлами различных форматов. 
Существует основных два типа операций с файлами в рамках протокола **HTTP**:
 
 - **Upload** — отправка файла на удаленный сервер, ввиде последовательности байт
      
 - **Download** — или отправка запроса к удаленному серверу на получение массива байт, и его дальнейшей записи в пустой файл

В случае если файл имеет небольшой размер, допустима передача его содержимого одним фрагментом, однако в большинстве случаев корректней
осуществлять передачу файла по частям, которые принято называть [чанками](https://ru.wikipedia.org/wiki/Chunked_transfer_encoding). 

Ниже приведены примеры скачивания (**Download**) и загрузки (**Upload**) содержимого файлов по фрагментам, с помощью базовых методов библиотеки **requests**

**Скачивание файла с удаленного сервера (Download)**
```python
import requests # Импортируем библиотеку requests
from requests.exceptions import RequestException # Импортируем исключение RequestException

try:
    res = requests.get("https://httpbin.org/image/png", stream=True) # Делаем GET запрос для получения файла с удаленного сервера ввиде последовательности байт
    res.raise_for_status()

    if res.status_code == 200: 
        with open("image.png", "wb") as file: # Открываем файл image.png на запись байтов без кодировки
            for chunk in res.iter_content(chunk_size=2048): file.write(chunk) # Записываем изображение в файл image.png по 2048 байт за итерацию
            print("Скачивание завершено") # Отображаем уведомление об успешном завершении операции 

except requests.exceptions.RequestError as e: print(f"Произошла ошибка при скачивании файла: {e}")
```

**Загрузка файла на удаленный сервер (Upload)**
```python
import requests # Импортируем библиотеку requests
from requests.exceptions import RequestException # Импортируем исключение

file = {"file": open("filename.ext", "rb")} # Содержимое файла ввиде последовательности байт внутри словаря

try:
  res = requests.post("https://httpbin.org/post", files=file) # Делаем POST запрос к https://httpbin.org/post загружая на сервер файл ввиде последовательности байт
  print(f"[{res.status_code}] Файл был загружен по адресу {res.url}") # Отображаем уведомление об успешной загрузке файла на сервер 

except RequestException as e: print(f"Произошла ошибка при загрузке файла: {e}")
```

## Аутентификация

**Аутентификация** — в контексте протокола **HTTP** представляет собой механизм, нацеленный на проверку подлинности пользователя некого ресурса, для дальнейшего контроля доступа последнего к ресурсу. В протоколе **HTTP** в общем, и библиотеке **requests** в частности, предусмотрено несколько видов аутентификации. Данные механизмы разнятся по формату передаваемых данных, а также уровню их защиты, поэтому для обеспечения надежной защиты доступа к целевому ресурсу, представленные методы стоит применять учитывая особенности отдельной взятой задачи, а также использовать комбинации методов при наличии такой возможности. Примеры использования основных методов аутентификации, а также их более детальное рассмотрение представлены ниже

### HTTPBasicAuth
Данный метод аутентификации является наименее защищенным методом аутентификации из представленных. Передает имя пользователя (**username**) и его пароль (**password**) в кодировке [base64](https://ru.wikipedia.org/wiki/Base64). 
Применение **HTTPBasicAuth** допустимо при наличии изолированного канала передачи данных, в противном случае незашифрованные данные в формате [base64](https://ru.wikipedia.org/wiki/Base64) могут быть перехвачены сторонним лицом, и декодированы в учетные данные отправленные клиентом

**Пример использования HTTPBasicAuth**
```python
import requests # Импортируем библиотеку requests
from requests.auth import HTTPBasicAuth # Импортируем класс базовой аутентификации

res = requests.get("https://httpbin.org/basic-auth/", auth=HTTPBasicAuth("username", "password")) # Делаем GET запрос к указанному URL с использованием аутентификации HTTPBasicAuth
print("Аутентификация успешно завершена" if res.status_code == 200 else "Ошибка аутентификации")

```
### HTTPDigestAuth
В отличии от метода HTTPBasicAuth, данный механизм аутентификации является более предпочительным с точки зрения защищенности передаваемых данных. Вместо передачи учетных данных в открытом виде, **HTTPDigestAuth** использует алгоритм, построеный на обмене дайджестами (**Digest**) между клиентом и сервером, что были сгенерированы с использованием алгоритмов хеширования (**MD5**, **SHA**). Данный подход позвояет избежать открытую передачу учетных данных, что является его достоинством, однако **HTTPDigestAuth** все равно подвержен ряду уязвимостей, поэтому также не может считаться полностью защищенным

**Пример использования HTTPDigestAuth**
```python
import requests # Импортируем библиотеку requests
from requests.auth import HTTPDigestAuth # Импортируем класс digest-аутентификации

res = requests.get("https://httpbin.org/digest-auth/", auth=HTTPDigestAuth("username", "password")) # Делаем GET запрос к указанному URL с использованием аутентификации HTTPDigestAuth
print("Аутентификация успешно завершена" if res.status_code == 200 else "Ошибка аутентификации")

```

### Пользовательская реализация аутентификации (AuthBase)
Стоит отметить что все ранее рассмотренные классы методов аутентификации построены на базе родительского класса аутентификации **AuthBase**. Из этого следует, что библиотека **requests** предоставляет возможность создания собственные классов аутентификации, основанных на родительском классе **AuthBase**. Необходимость в создании собственных классов аутентификации возникает весьма редко, однако для решения некоторых задач, например использования **API-токена** в качестве метода аутентификации, создание дочерних классов **AuthBase** является оптимальным решением

**Пример использования пользовательского класса аутентификации**
```python
import requests # Импортируем библиотеку requests
from requests.auth import AuthBase # Импортируем базовый класс аутентификации AuthBase

class HTTPTokenAuth(AuthBase): 
  def __init__(self, token):
    self.token = token # Инициализируем атрибут token, служащий для хранения токена аутентификации

  def __call__(self, request):
    request.headers["Authorization"] = self.token  # Устанавливаем значение атрибута token в качестве значения заголовка Authorization
    return request # Возвращаем экземпляра класса Request с токеном аутентификации

res = requests.get("https://httpbin.org/bearer", auth=HTTPTokenAuth("token")) # Делаем GET запрос к указанному URL с использованием кастомной реализации аутентификации
print("Аутентификация с использованием токена успешно завершена" if res.status_code == 200 else "Ошибка аутентификации через токен")

```

## HTTP сессии
Зачастую при работе с протоколом **HTTP** возникает необходимость отправки большого числа запросов в рамках короткого временного интервала, однако все может стать сложнее, если запросы имеют сложную конфигурацию, например, пользовательские заголовки, или передаются через прокси сервер. Для решения подобных задач, в протоколе **HTTP** присутствует механизм под названием сессии (**Session**).

Главное отличие режима сессий от классических запросов заключается в том, что при использовании сессии клиент и сервер сохраняют прежнюю конфигурацию запросов, и продолжают обмен данными в рамках одного контекста. Реализован данный механизм может при помощи использования ряда методов, например, использования установленного единожды **TCP** соединения для выполнения двух и более запросов к удаленному серверу, или хранения данных от сессии в формате **cookie** заголовка, который мы рассмотрели ранее.

Библиотека **requests** также предоставляет интерфейс для использования данного механизма, поэтому ниже мы рассмотрим пример практического применения данной концепции на двух примерах

**Использование Session для смены User-Agent**
```python
import requests
from requests.exceptions import RequestException

try:
    with requests.Session() as session:
        print(session.get('https://ifconfig.me/ua').text)

        session.headers.update({"User-Agent": "custom-useragent/1.0"})
 
        print(session.get('https://ifconfig.me/ua').text)

except requests.exceptions.RequestError as e: print(e)
```

**Использование Session для отправки запросов разных методов в рамках одной сессии**
```python
import requests
from requests.exceptions import RequestException

try:
    data = {"data": "data"}
    with requests.Session() as session:
        print(session.get('https://httpbin.org/get').url)
        print(session.post('https://httpbin.org/post', data=data).url)
        print(session.put('https://httpbin.org/put', data=data).url)
        print(session.delete('https://httpbin.org/delete').url)

except requests.exceptions.RequestError as e: print(e)
```
